/*
 * SNMPStats Module  - Network Statistics
 *
 * Copyright (C) 2006 SOMA Networks, INC.
 * Written by: Jeffrey Magder (jmagder@somanetworks.com)
 *
 * Kamailio Server Net objects addition
 * Copyright (C) 2013 Edvina AB, Sollentuna, Sweden
 * Written by Olle E. Johansson
 *
 * This file is part of Kamailio, a free SIP server.
 *
 * Kamailio is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version
 *
 * Kamailio is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 *
 * History:
 * --------
 * 2013-03-24 initial version (oej)
 * 
 * Note: this file originally auto-generated by mib2c 
 *
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "kamailioNet.h"

#include "snmpstats_globals.h"
#include "utilities.h"
#include "../../lib/kcore/statistics.h"
#include "../../globals.h"
#include "../../tcp_options.h"

/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */


/** Initializes the kamailioNet module */
void
init_kamailioNet(void)
{
    const oid kamailioNetTcpConnEstablished_oid[] = { 1,3,6,1,4,1,34352,3,1,3,1,4,1,2,1 };
    const oid kamailioNetTcpConnFailed_oid[] = { 1,3,6,1,4,1,34352,3,1,3,1,4,1,2,2 };
    const oid kamailioNetTcpConnReset_oid[] = { 1,3,6,1,4,1,34352,3,1,3,1,4,1,2,3 };
    const oid kamailioNetTcpConnSuccess_oid[] = { 1,3,6,1,4,1,34352,3,1,3,1,4,1,2,4 };
    const oid kamailioNetTcpConnOpened_oid[] = { 1,3,6,1,4,1,34352,3,1,3,1,4,1,2,5 };
    const oid kamailioNetTcpConnPassiveOpen_oid[] = { 1,3,6,1,4,1,34352,3,1,3,1,4,1,2,6 };
    const oid kamailioNetTcpConnReject_oid[] = { 1,3,6,1,4,1,34352,3,1,3,1,4,1,2,8 };
    const oid kamailioNetTcpEnabled_oid[] = { 1,3,6,1,4,1,34352,3,1,3,1,4,1,3,1 };
    const oid kamailioNetTcpMaxConns_oid[] = { 1,3,6,1,4,1,34352,3,1,3,1,4,1,3,2 };
    const oid kamailioNetTcpAsync_oid[] = { 1,3,6,1,4,1,34352,3,1,3,1,4,1,3,3 };

  DEBUGMSGTL(("kamailioNet", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("kamailioNetTcpConnEstablished", handle_kamailioNetTcpConnEstablished,
                               kamailioNetTcpConnEstablished_oid, OID_LENGTH(kamailioNetTcpConnEstablished_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("kamailioNetTcpConnFailed", handle_kamailioNetTcpConnFailed,
                               kamailioNetTcpConnFailed_oid, OID_LENGTH(kamailioNetTcpConnFailed_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("kamailioNetTcpConnReset", handle_kamailioNetTcpConnReset,
                               kamailioNetTcpConnReset_oid, OID_LENGTH(kamailioNetTcpConnReset_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("kamailioNetTcpConnSuccess", handle_kamailioNetTcpConnSuccess,
                               kamailioNetTcpConnSuccess_oid, OID_LENGTH(kamailioNetTcpConnSuccess_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("kamailioNetTcpConnOpened", handle_kamailioNetTcpConnOpened,
                               kamailioNetTcpConnOpened_oid, OID_LENGTH(kamailioNetTcpConnOpened_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("kamailioNetTcpConnPassiveOpen", handle_kamailioNetTcpConnPassiveOpen,
                               kamailioNetTcpConnPassiveOpen_oid, OID_LENGTH(kamailioNetTcpConnPassiveOpen_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("kamailioNetTcpConnReject", handle_kamailioNetTcpConnReject,
                               kamailioNetTcpConnReject_oid, OID_LENGTH(kamailioNetTcpConnReject_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("kamailioNetTcpEnabled", handle_kamailioNetTcpEnabled,
                               kamailioNetTcpEnabled_oid, OID_LENGTH(kamailioNetTcpEnabled_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("kamailioNetTcpMaxConns", handle_kamailioNetTcpMaxConns,
                               kamailioNetTcpMaxConns_oid, OID_LENGTH(kamailioNetTcpMaxConns_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("kamailioNetTcpAsync", handle_kamailioNetTcpAsync,
                               kamailioNetTcpAsync_oid, OID_LENGTH(kamailioNetTcpAsync_oid),
                               HANDLER_CAN_RONLY
        ));
}

#ifdef SKREP
	con_timeout: 0
	connect_success: 0
	current_write_queue_size: 0
	local_reject: 0
	passive_open: 0
	send_timeout: 0
	sendq_full: 0
#endif

int
handle_kamailioNetTcpConnEstablished(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

	int datafield = get_statistic("established");
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
			(u_char *) &datafield, sizeof(int));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_kamailioNetTcpConnEstablished\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_kamailioNetTcpConnFailed(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

	int datafield = get_statistic("connect_failed");
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
			(u_char *) &datafield, sizeof(int));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_kamailioNetTcpConnFailed\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_kamailioNetTcpConnReset(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	int datafield = get_statistic("con_reset");
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
			(u_char *) &datafield, sizeof(int));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_kamailioNetTcpConnReset\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_kamailioNetTcpConnSuccess(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

	int datafield = get_statistic("connect_success");
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
			(u_char *) &datafield, sizeof(int));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_kamailioNetTcpConnSuccess\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_kamailioNetTcpConnOpened(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	int datafield = get_statistic("current_opened_connections");
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE,
			(u_char *) &datafield, sizeof(int));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_kamailioNetTcpConnOpened\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_kamailioNetTcpConnPassiveOpen(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	int datafield = get_statistic("passive_open");
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
			(u_char *) &datafield, sizeof(int));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_kamailioNetTcpConnPassiveOpen\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_kamailioNetTcpConnReject(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	int datafield = get_statistic("local_reject");
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
			(u_char *) &datafield, sizeof(int));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_kamailioNetTcpConnReject\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_kamailioNetTcpEnabled(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	int enabled = (tcp_disable == 0);
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
			(u_char *) &enabled, sizeof(int));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_kamailioNetTcpEnabled\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_kamailioNetTcpMaxConns(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    struct cfg_group_tcp t;
    unsigned int maxconn;

    tcp_options_get(&t);
    maxconn = t.max_connections;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
			 (u_char *) &maxconn, sizeof(int));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_kamailioNetTcpMaxConns\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_kamailioNetTcpAsync(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    struct cfg_group_tcp t;
    unsigned int value;

    tcp_options_get(&t);
    value = t.async;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
			 (u_char *) &value, sizeof(int));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_kamailioNetTcpAsync\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
